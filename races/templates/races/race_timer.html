{% extends "base.html" %}
{% block content %}

<style>
.lap-btn {
    width: 100%;
    touch-action: manipulation;
}

/* simple, stable indicators */
.lap-coming { border: 4px solid #20c997 !important; }
.lap-late   { border: 4px solid #dc3545 !important; }

.sort-warning {
    background: #ffc107;
    color: black;
    font-weight: bold;
}

/* sticky header */
#sticky-header {
    position: sticky;
    top: 0;
    z-index: 1000;
    background: var(--bs-body-bg);
    padding: 8px 0;
    border-bottom: 1px solid #ddd;
}

.boat-grid {
    display: flex;
    flex-wrap: wrap;
}

.boat-tile {
    width: 150px;
}
</style>

<input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">

<h2>Race Timer ‚Äì {{ race }}</h2>

<div id="sticky-header">

    <div id="start-controls" class="d-flex gap-2 mb-2">
        <button id="btn-5" class="btn btn-primary">5 min</button>
        <button id="btn-3" class="btn btn-primary">3 min</button>
        <button id="btn-1" class="btn btn-primary">1 min</button>
        <button id="btn-now" class="btn btn-danger">Immediate</button>
    </div>

    <button id="restart-btn" class="btn btn-warning mb-2 d-none">
        Restart
    </button>

    <h2 id="clock" class="display-6 fw-bold">00:00</h2>


    <div class="mb-2">
        <button class="btn btn-sm btn-outline-secondary"
                data-bs-toggle="collapse"
                data-bs-target="#prediction-panel">
            Predicted Finish
        </button>

        <button id="sort-advice-btn"
                class="btn btn-sm btn-outline-secondary ms-2">
            Sort By Predicted Arrival
        </button>

        <span id="sync-indicator" class="badge bg-success ms-2">
            SYNC
        </span>

        <button id="toggle-offline" class="btn btn-sm btn-outline-danger ms-2">
            Simulate Offline
        </button>
        <button id="clear-queue" class="btn btn-sm btn-outline-secondary">
            Clear Queue
        </button>

        <div id="prediction-panel" class="collapse mt-2">
            <table class="table table-sm table-borderless small text-muted mb-0">
                <thead>
                    <tr>
                        <th>Pos</th>
                        <th>Helm</th>
                        <th>Laps</th>
                        <th>Last</th>
                        <th>Next</th>
                        <th>Corrected</th>
                    </tr>
                </thead>
                <tbody id="prediction-body"></tbody>
            </table>
        </div>
    </div>
</div>

<!-- BOATS -->
<div id="boat-grid" class="boat-grid">
{% for e in entries %}
    <div class="boat-tile" data-id="{{ e.id }}">
        <div class="card">
            <div class="card-body p-2">

                <button class="btn btn-lg btn-primary lap-btn mb-2"
                        data-id="{{ e.id }}"
                        data-py="{{ e.py_used|stringformat:'s' }}"
                        data-helm="{{ e.helm.username }}">

                    <div class="fw-bold fs-4">
                        {{ e.boat.sail_number }}
                    </div>

                    <div style="font-size: 0.7rem;">
                        {{ e.boat.boat_type.name }}<br>
                        Helm: {{ e.helm.get_short_name }}
                    </div>

                    <div class="mt-1 small">
                        Lap: <span class="lap-count">0</span> |
                        Last: <span class="last-time">--</span>
                    </div>
                </button>

                <button class="btn btn-sm btn-outline-secondary w-100 undo-btn"
                        data-id="{{ e.id }}">
                    Undo Last Lap
                </button>

            </div>
        </div>
    </div>
{% endfor %}
</div>

<button class="btn btn-dark mt-3" id="finish-btn">
    Finish Race
</button>

{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
<script>
let forceOffline = false;

document.addEventListener("DOMContentLoaded", function () {

const BUNCH_WINDOW = 5;

const clock = document.getElementById("clock");
const startControls = document.getElementById("start-controls");
const restartBtn = document.getElementById("restart-btn");
const sortBtn = document.getElementById("sort-advice-btn");
const grid = document.getElementById("boat-grid");

let startTime = null;
let timerInterval = null;
let countdownInterval = null;

const lapData = {};
const lapButtons = document.querySelectorAll(".lap-btn");
let currentPredictions = [];

/* =====================================================
   SYNC
===================================================== */
let deviceId = localStorage.getItem("device_id");
if (!deviceId) {
    deviceId = crypto.randomUUID();
    localStorage.setItem("device_id", deviceId);
}

let sequence = parseInt(localStorage.getItem("sequence") || "1");
let queue = JSON.parse(localStorage.getItem("event_queue") || "[]");
let allowExit = false;

setSync(queue.length === 0);
/* ===================================================== */
window.addEventListener("beforeunload", function (e) {
    if (!allowExit && queue.length > 0) {
        e.preventDefault();
        e.returnValue = "Data not synced!";
    }
});
/* ===================================================== */
function setSync(ok) {
    const syncIndicator = document.getElementById("sync-indicator");
    if (!syncIndicator) return;

    if (ok && queue.length === 0) {
        syncIndicator.classList.remove("bg-danger");
        syncIndicator.classList.add("bg-success");
        syncIndicator.textContent = "SYNC";
    } else {
        syncIndicator.classList.remove("bg-success");
        syncIndicator.classList.add("bg-danger");
        syncIndicator.textContent = `OFFLINE (${queue.length})`;
    }
}

/* ===================================================== */
function saveQueue() {
    localStorage.setItem("event_queue", JSON.stringify(queue));
    localStorage.setItem("sequence", sequence);
}

function sendToServer(event) {
    if (forceOffline) return Promise.reject("offline");

    return fetch("/races/api/race-event/", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(event)
    });
}

function enqueueEvent(event) {
    queue.push(event);
    saveQueue();
    setSync(false);
}
/* ===================================================== */
function processQueue() {

    if (!queue.length) {
        setSync(true);
        return;
    }

    // send events back-to-back until one fails
    const sendNext = () => {

        if (!queue.length) {
            setSync(true);
            return;
        }

        const event = queue[0];

        sendToServer(event)
            .then(r => {
                if (!r.ok) throw "fail";

                queue.shift();     // remove
                saveQueue();

                sendNext();        // üî• immediately send the next one
            })
            .catch(() => {
                setSync(false);    // stop if network bad again
            });
    };

    sendNext();
}
/* ===================================================== */

setInterval(processQueue, 2000);

const RACE_ID = Number("{{ race.id }}");
/* ===================================================== */
function sendEvent(type, raceEntryId = null, raceSeconds = null) {
    const event = {
        race: RACE_ID,
        device_id: deviceId,
        sequence: sequence++,
        event_type: type,
        race_entry: raceEntryId,
        race_seconds: raceSeconds
    };

    sendToServer(event)
        .then(r => {
            if (!r.ok) throw "fail";
            setSync(true);
        })
        .catch(() => enqueueEvent(event));

    saveQueue();
}

/* ===================================================== */
const sortable = Sortable.create(grid, {
    animation: 0,
    draggable: ".boat-tile",
    dataIdAttr: "data-id"
});

/* ===================================================== */
function enableLaps(enabled) {
    lapButtons.forEach(b => b.disabled = !enabled);
}
enableLaps(false);

/* ===================================================== */
function startRaceClock() {
    clearInterval(countdownInterval);
    clearInterval(timerInterval);

    enableLaps(true);
    startTime = Date.now();

    timerInterval = setInterval(tick, 1000);
    sendEvent("start");
}

function tick() {
    if (!startTime) return;

    const diff = Math.floor((Date.now() - startTime) / 1000);
    clock.textContent = fmt(diff);
    updatePredictions();
}

/* ===================================================== */
function startCountdown(minutes) {

    if (startTime !== null || countdownInterval !== null) {
        if (!confirm("Restart sequence? All times will be lost.")) return;
        resetRace();
    }

    startControls.classList.add("d-none");
    restartBtn.classList.remove("d-none");

    let remaining = (minutes * 60) + 10;

    countdownInterval = setInterval(() => {
        remaining--;
        clock.textContent = `Start in ${fmt(remaining)}`;
        if (remaining === 0) startRaceClock();
    }, 1000);
}

document.getElementById("btn-5").onclick = () => startCountdown(5);
document.getElementById("btn-3").onclick = () => startCountdown(3);
document.getElementById("btn-1").onclick = () => startCountdown(1);
document.getElementById("btn-now").onclick = () => startCountdown(0);

/* ===================================================== */
restartBtn.onclick = () => {
    if (!confirm("Restart race?")) return;
    resetRace();
    sendEvent("restart");
};

function resetRace() {
    clearInterval(timerInterval);
    clearInterval(countdownInterval);
    startTime = null;
    clock.textContent = "00:00";
    enableLaps(false);

    startControls.classList.remove("d-none");
    restartBtn.classList.add("d-none");

    Object.values(lapData).forEach(d => {
        d.laps = 0;
        d.times = [];
    });

    document.querySelectorAll(".lap-count").forEach(e => e.textContent = 0);
    document.querySelectorAll(".last-time").forEach(e => e.textContent = "--");

    currentPredictions = [];
    updatePredictions();
}

/* ===================================================== */

document.getElementById("clear-queue").onclick = () => {
    localStorage.removeItem("event_queue");
    localStorage.removeItem("sequence");
    queue = [];
    sequence = 1;
    setSync(true);
    console.log("Queue cleared");
};

/* ===================================================== */
document.getElementById("toggle-offline").onclick = function () {
    forceOffline = !forceOffline;
    this.textContent = forceOffline ? "Offline Mode ON" : "Simulate Offline";
};

/* ===================================================== */
/* LAPS */
lapButtons.forEach(btn => {
    const id = btn.dataset.id;

    lapData[id] = {
        laps: 0,
        times: [],
        py: parseFloat(btn.dataset.py),
        helm: btn.dataset.helm
    };

    btn.addEventListener("click", () => {
        if (!startTime) return;

        const sec = Math.floor((Date.now() - startTime) / 1000);

        lapData[id].laps++;
        lapData[id].times.push(sec);

        btn.querySelector(".lap-count").textContent = lapData[id].laps;
        btn.querySelector(".last-time").textContent = fmt(sec);

        sendEvent("lap", id, sec);
        updatePredictions();
    });
});

/* ===================================================== */
document.querySelectorAll(".undo-btn").forEach(btn => {
    const id = btn.dataset.id;

    btn.addEventListener("click", () => {
        const d = lapData[id];
        if (!d.laps) return;

        d.laps--;
        d.times.pop();

        const card = btn.closest(".card");
        card.querySelector(".lap-count").textContent = d.laps;
        card.querySelector(".last-time").textContent =
            d.times.length ? fmt(d.times.at(-1)) : "--";

        sendEvent("undo", id);
        updatePredictions();
    });
});

/* ===================================================== */
document.getElementById("finish-btn").onclick = () => {
    if (!startTime) return;
    if (!confirm("Finish race?")) return;

    sendEvent("finish");
    allowExit = true;
    window.location.href = "../results/timed/";
};

/* ===================================================== */
function updatePredictions() {

    const body = document.getElementById("prediction-body");
    if (!body) return;

    document.querySelectorAll(".lap-btn")
        .forEach(b => b.classList.remove("lap-coming","lap-late"));

    const rows = [];
    const maxLaps = Math.max(...Object.values(lapData).map(d => d.laps || 0));
    const now = startTime ? Math.floor((Date.now() - startTime) / 1000) : 0;

    Object.entries(lapData).forEach(([id, d]) => {
        if (!d.laps || !d.py) return;

        const last = d.times.at(-1);
        const avg = last / d.laps;
        const next = last + avg;
        const corrected = last * (maxLaps / d.laps) * 1000 / d.py;

        rows.push({ id, helm:d.helm, laps:d.laps, last, next, corrected });
    });

    rows.sort((a,b) => a.next - b.next);
    currentPredictions = rows;

    rows.forEach(r => {
        const btn = document.querySelector(`.lap-btn[data-id="${r.id}"]`);
        if (!btn) return;

        const eta = r.next - now;

        if (eta <= 10 && eta >= 0) btn.classList.add("lap-coming");
        else if (eta < 0) btn.classList.add("lap-late");
    });

    body.innerHTML = "";
    rows.forEach((r,i)=>{
        body.innerHTML += `
            <tr>
                <td>${i+1}</td>
                <td>${r.helm}</td>
                <td>${r.laps}</td>
                <td>${fmt(r.last)}</td>
                <td>${fmt(r.next)}</td>
                <td>${fmt(r.corrected)}</td>
            </tr>`;
    });
}

/* ===================================================== */
sortBtn.onclick = () => {
    if (!currentPredictions.length) return;
    sortable.sort(currentPredictions.map(r => String(r.id)));
};

/* ===================================================== */
function fmt(sec){
    if (sec == null) return "--";

    sec = Math.round(sec);   // ‚≠ê key line

    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return `${m}:${s.toString().padStart(2,"0")}`;
}


});
</script>
{% endblock %}
